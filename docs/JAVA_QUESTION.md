# 자바 핵심 개념 정리
<details>
<summary>Java에서 제공하는 원시 타입들에 무엇이 있고, 각각 몇 바이트를 차지하나요?</summary>
<div markdown="1">
Java에서는 boolean, char, byte, short, int, long, float, double 총 8가지의 원시 타입이 제공된다.<br>
- boolean: 1bit<br>
- char: 2byte<br>
- byte: 1byte<br>
- short: 2byte<br>
- int: 4byte<br>
- long: 8byte<br>
- float: 4byte<br>
- double: 8byte<br>
</div>
</details>
<br>

<details>
<summary>오버라이딩(OverRiding)과 오버로딩(OverLoading)에 대해 설명해주세요.</summary>
<div markdown="1">
오버라이딩은 슈퍼 클래스에 있는 메소드와 이름, 매개 변수 타입과 개수, 리턴 타입 등이 모두 동일한 메소드가 서브 클래스에 재정의된 경우이다. 
오버라이딩은 슈퍼 클래스에 구현된 메소드를 무시하고 서브 클래스에서 새로운 기능의 메소드를 재정의하고자 한다. 
오버라이딩은 메소드의 이름, 인자의 타입, 인자의 개수, 리턴 타입 등이 모두 동일해야 성립한다.<br>
오버로딩은 한 클래스나 상속 관계에 있는 클래스에 서로 매개 변수의 타입이나 개수가 다른 여러 개의 메소드가 같은 이름으로 작성되는 것이다. 
오버로딩은 이름이 같은 여러 개의 메소드를 중복 선언하여 사용의 편리성을 향상하고자 한다. 
오버로딩은 메소드 이름이 반드시 동일해야 하고, 메소드의 인자의 개수나 인자의 타입이 달라야 성립한다.
</div>
</details>
<br>

<details>
<summary>객체지향 프로그래밍(OOP)에 대해 설명해주세요</summary>
<div markdown="1">
객체 지향 언어는 실세계의 객체를 프로그램 내에 표현하기 위해 클래스와 객체 개념을 도입했다. 
OOP는 객체의 관점에서 프로그래밍 하는 것이며, 객체들의 유기적인 관계를 통해 프로세스가 진행된다.<br>
객체지향 프로그래밍의 특징은 추상화, 캡슐화, 상속, 그리고 다형성이다.<br>
1. 추상화: 불필요한 정보는 숨기고 중요한 정보만을 표현해서 프로그래밍 하는 것<br>
2. 캡슐화: 객체를 캡슐로 싸서 그 내부를 보호하고 볼 수 없도록 하는 것 (정보 은닉)<br>
3. 상속: 상위 객체의 속성이 하위 개체에 물려져서 하위 개체가 상위 개체의 속성을 모두 가지는 관계<br>
4. 다형성: 같은 이름의 메소드가 클래스 또는 객체에 따라 다르게 구현되는 것<br>
이러한 객체지향 프로그래밍은 소프트웨어 재사용과 유지보수의 효율성을 높여 궁극적으로 소프트웨어 생산성을 향상시킨다.
</div>
</details>
<br>

<details>
<summary>추상 클래스와 인터페이스에 대해 설명해주시고, 차이에 대해 설명해주세요.</summary>
<div markdown="1">
추상 클래스는 abstract 키워드와 함께 원형만 선언되고, 코드는 작성되지 않은 메소드이다.<br>
인터페이스는 interface 키워드를 사용하여 클래스를 선언하듯이 선언한다.<br>
추상 클래스와 인터페이스는 추상 메소드의 선언만 있고, 구현 내용이 없다는 공통점이 있다.
추상 클래스는 extends 키워드를 사용하여 상속하고, 다중 상속은 불가능하다. 
그러나 인터페이스는 implements 키워드를 사용하여 상속하고, 다중 상속이 가능하다는 차이가 있다.
</div>
</details>
<br>

<details>
<summary>가비지 컬렉션(gc)란 무엇일까요?</summary>
<div markdown="1">
가용 메모리 공간이 일정 크기 이하로 줄어들면 자바 가상 기계는 자동으로 가비지를 회수하여 가용 메모리 공간을 늘리는데 이것이 가비지 컬렉션이다. 
가비지가 많아지면 응용프로그램에게 할당해줄 수 있는 가용 메모리의 양이 줄어든다. 
가비지가 점점 늘어가 가용 메모리가 0이 되면 자바 응용프로그램은 더 이상 실행될 수 없기 때문에 자바에서 가비지 컬렉션은 반드시 필요하고, 
가비지 컬렉션은 자바 가상 기계 내에 준비된 가비지 컬렉션 스레드에 의해 처리된다.
</div>
</details>
<br>

<details>
<summary>JVM의 동작 방식에 대해 설명해 주세요.</summary>
<div markdown="1">
Java 프로그램은 JVM이 아래의 방식으로 동작하며 실행되게 된다.<br>
1. 자바 프로그램을 실행하면 JVM은 OS로부터 메모리를 할당 받는다. <br>
2. 자바 컴파일러가 자바 소스코드(.java)를 자바 바이트 코드(.class)로 컴파일한다.<br>
3. Class Loader에서 바이트 코드를 JVM Data Runtime Area로 로딩한다.<br>
4. 로딩된 바이트 코드는 Execution Engine을 통해 기계어로 해석되고 실행된다.
</div>
</details>
<br>

<details>
<summary>불변 객체란 무엇이고, final은 무엇일까요? 사용하는 이유와 함께 설명해주세요.</summary>
<div markdown="1">
불변 객체란 객체 생성 이후 내부의 상태가 변하지 않는 객체이다. final로 선언된 클래스는 더 이상 상속되지 않고, 
final로 선언된 메소드는 더 이상 오버라이딩될 수 없으며, final로 선언된 필드는 상수이기 때문에 실행 중에 값을 변경할 수 없다.<br>
불변 객체와 final을 사용하면 Thread-Safe하여 병렬 프로그래밍에 유용하고 동기화를 고려하지 않아도 된다. 또한, Cache나 Map 또는 Set의 
요소로 활용하기에 적합하여 오류가능성을 최소화할 수 있다. 따라서 불변성이 보장되어 안전하기 때문에 불변 객체와 final을 사용한다.
</div>
</details>
<br>

<details>
<summary>자바의 메모리 영역에 대해 설명해주세요.</summary>
<div markdown="1">
메소드 영역: JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 메소드 정보, static 변수, 변수 정보, 클래스 정보 등을 저장<br>
힙 영역: 인스턴스 또는 객체를 저장하며, 런타임 시 결정되는 참조형 데이터타입 저장<br>
스택 영역: 메소드를 호출할 때 생성되며 종료 시에 같이 제거되는 영역으로, 지역변수, 매개변수, 리턴값, 참조변수 등이 저장됨
</div>
</details>
<br>

<details>
<summary>new String()과 리터럴(" ")의 차이에 대해 설명해주세요.</summary>
<div markdown="1">
new String()으로 String 객체를 생성하면 새 객체는 Heap 메모리 영역에 저장된다.
리터럴(" ")을 사용하여 객체를 생성하는 경우에는 만약 해당 문자열이 String Constant Pool에 이미 존재하는 문자열이라면 
기존에 생성해 둔 객체를 반환할 수 있다. 만약 존재하지 않더라도, 새롭게 String 객체를 String Constant Pool에 저장함으로써 
이후 똑같은 문자열 리터럴을 사용하였을 때 기존 값을 재사용 할 수 있다.
</details>
<br>

<details>
<summary>⭐️ 추가 과제: 람다(lambda)에 대해 알아볼까요?</summary>
<div markdown="1">
람다식은 메소드를 간단한 식으로 표현하는 방법이다. 이름이 없는 익명 함수도 람다식이라고 칭한다.<br>
람다식을 작성하기 위해서는 메소드의 이름과 반환 타입을 제거하고 '->'를 블록{} 앞에 추가한다. 
반환값이 있는 경우에는 식이나 값만 적고 return문을 생략해도 된다. 끝에 세미콜론(;)은 붙이지 않는다. 
그리고 매개변수의 타입이 추론 가능하다면 생략이 가능하다.
</div>
</details>
<br>

<details>
<summary>⭐️ 추가 과제: 스트림(stream)에 대해 알아볼까요?</summary>
<div markdown="1">
스트림은 다양한 데이터 소스를 표준화된 방법으로 다루기 위한 것이다. 스트림은 중간 연산과 최종 연산 기능을 제공한다. 
중간 연산은 연산 결과가 스트림인 연산으로, 반복적으로 적용 가능하다. 
반면, 최종 연산은 연산 결과가 스트림이 아닌 연산으로, 한 번만 적용 가능하다.
</div>
</details>
<br>

